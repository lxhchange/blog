(self.webpackChunkblog=self.webpackChunkblog||[]).push([[905],{748:(t,e,a)=>{"use strict";a.r(e),a.d(e,{data:()=>n});const n={key:"v-6fcf81b6",path:"/re-study/variable.html",title:"重学前端 第一篇 变量",lang:"zh-CN",frontmatter:{title:"重学前端 第一篇 变量",description:"重学前端"},excerpt:"",headers:[{level:2,title:"变量类型",slug:"变量类型",children:[{level:3,title:"数字类型",slug:"数字类型",children:[]},{level:3,title:"布尔类型",slug:"布尔类型",children:[]},{level:3,title:"参考链接",slug:"参考链接",children:[]}]}],filePathRelative:"re-study/variable.md",git:{updatedTime:1628847305e3,contributors:[]}}},451:(t,e,a)=>{"use strict";a.r(e),a.d(e,{default:()=>N});var n=a(252);const r=(0,n.uE)('<h2 id="变量类型" tabindex="-1"><a class="header-anchor" href="#变量类型" aria-hidden="true">#</a> 变量类型</h2><p>JS中变量分为 基本类型 和 复杂类型，基本类型包含：null, undefined, Number, String, Boolean, Symbol 共六种， 复杂类型是 指 Object</p><p>null 和 undefined 分别表示 空引用 和 没有设置值</p><h3 id="数字类型" tabindex="-1"><a class="header-anchor" href="#数字类型" aria-hidden="true">#</a> 数字类型</h3><p>在JS中数字类型通过Number表示，它的最大（小）整数 可以通过 Number.MAX(MIN)_SAFE_INTEGER</p><p>从其它类型转换到Number的方法主要是: <strong>Number</strong> 和 <strong>parseInt</strong>, <strong>parseFloat</strong>, 后二者主要用于 字符串转换到 数字</p><table><thead><tr><th></th><th>Number</th><th>parseInt</th><th>parseFloat</th></tr></thead><tbody><tr><td>Null</td><td>0</td><td>NaN</td><td>NaN</td></tr><tr><td>Undefined</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><td>&#39;1a&#39;</td><td>NaN</td><td>1</td><td>1.0</td></tr><tr><td>&#39;0xa&#39;</td><td>10</td><td>10</td><td>0</td></tr><tr><td>True/false</td><td>1 / 0</td><td>NaN</td><td>NaN</td></tr><tr><td>Symbol</td><td>Error</td><td>Error</td><td>Error</td></tr><tr><td>空字符串</td><td>0</td><td>NaN</td><td>NaN</td></tr></tbody></table><p>差异在于, Numer只识别数字，如果包含非数字类型的字符，直接返回NaN, parseInt 和 parseFloat是从第一个非空字符串开始 到最后一个非空字符串</p><p>在JS中，浮点运算是会丢失精度的，比如</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">===</span> <span class="token number">0.3</span> <span class="token comment">// false, 实际是0.30000000000000004</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div>',10),s=(0,n.Uk)("原因是使用IEEE-754 (双精度 64位存储，1 - 10 - 53)格式存储浮点数字，有比较多的第三方库可以处理这种精度丢失的问题，比如 "),d=(0,n.Wm)("em",null,"big.js",-1),l=(0,n.Uk)(", "),i=(0,n.Wm)("em",null,"bignumber.js",-1),o=(0,n.Uk)(", "),p=(0,n.Wm)("em",null,"decimal.js",-1),c=(0,n.Uk)(" and "),u=(0,n.Wm)("em",null,"bigdecimal.js",-1),h=(0,n.Uk)("，它们之间的性能对比"),b={href:"https://jsperf.com/bignumber-js-vs-big-js-vs-decimal-js/8",target:"_blank",rel:"noopener noreferrer"},m=(0,n.Uk)("here"),g=(0,n.uE)('<h4 id="bigint" tabindex="-1"><a class="header-anchor" href="#bigint" aria-hidden="true">#</a> BigInt</h4><p>可以表示大于 2^53 - 1 的数字，bigint类型 只能和 bigint类型 进行计算</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">9007199254740991n</span>\n<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token number">9007199254740991</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="布尔类型" tabindex="-1"><a class="header-anchor" href="#布尔类型" aria-hidden="true">#</a> 布尔类型</h3><p>布尔类型的转换规则如下：</p><table><thead><tr><th></th><th>Boolean (!)</th></tr></thead><tbody><tr><td>0 / 1</td><td>false / true</td></tr><tr><td>空字符串</td><td>false</td></tr><tr><td>非空字符串</td><td>true</td></tr><tr><td>null</td><td>False</td></tr><tr><td>Undefined</td><td>False</td></tr><tr><td>Object</td><td>True</td></tr></tbody></table><h3 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h3><ol><li>https://www.avioconsulting.com/blog/overcoming-javascript-numeric-precision-issues</li></ol>',8),N={render:function(t,e){const a=(0,n.up)("OutboundLink");return(0,n.wg)(),(0,n.j4)(n.HY,null,[r,(0,n.Wm)("p",null,[s,d,l,i,o,p,c,u,h,(0,n.Wm)("a",b,[m,(0,n.Wm)(a)])]),g],64)}}}}]);